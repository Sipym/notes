# CPU概述
## CPU的基本功能
**功能**: 周而复始的执行指令;能够发现和处理异常情况和中断情况   

**CPU执行一条指令的大致过程**:对第1,2步，所有指令的操作都一样.  
1. 取指令，从`PC指向的内存单元`中`取出指令`送到`指令寄存器(IR)`中
2. 对IR中的指令操作码`译码`并`计算下条指令地址`  
3. 计算源操作数地址并取源操作数  
4. 对操作数进行相应的运算  
5. 计算目的操作数地址并存结果  

**寄存器传送机(RTL)语言**: 形式化描述上述基本操作  
**本书RTL语言规定**:  
   - `R[r]`: 表示通用寄存器r的内容  
   - `M[addr]`: 表示存储单元addr的内容  
   - `M[R[r]]`: 表示寄存器r的内容所指存储单元的内容  
   - `PC`: 表示PC的内容，指向要执行的指令的地址  
   - `M[PC]`: 表示PC所指存储单元的内容  
   - `SEXT[imm]`: 表示对imm进行<font color=purple>符号扩展</font>  
   - `ZEXT[imm]`: 表示对imm进行<font color=purple>零扩展</font>  
   - `传送方向`$\leftarrow$: 即传送源在右，传送目的在左  

## CPU的基本组成
**基本组成**: `数据通路`(datapath),`控制器`(control unit)  

**指令执行用到的元件**: `组合逻辑元件(操作元件)`,`存储元件(状态元件)`  
> 连接这些元件的方式: `总线方式`和`分散连接方式`  

数据通路就是由操作元件和存储元件通过总线方式或分散方式连接而成的<font color=purple>进行数据存储、处理和传送的路径</font>  

### 组合逻辑元件
**数据通路中最常用的组合逻辑元件**: 多路选择器(MUX)、加法器(Adder)、算术逻辑部件(ALU)等  
![img](img/数据通路中的常用组合逻辑元件.png '图1 数据通路中的常用组合逻辑元件 :size=100%')  
> 图中虚线表示控制信号  


### 状态元件
> 属于时序逻辑电路，具有存储功能。  

**数据通路中典型的状态存储元件**: 寄存器  
**不同类型的寄存器**:  
- 带"写使能"输入信号的`暂存寄存器`，用于实现指令寄存器、通用寄存器组等  
- 输出端`带三态门的寄存器`,通常用于与总线相连，通过三态门控制信息是否送到总线上  
- 带复位功能的寄存器  
- 带计数(自增)功能的寄存器  
- 带移位功能的寄存器  


## 数据通路与时序控制
![img](img/数据通路和时间周期.png '图2 数据通路和时间周期 :size=100%')  
**数据通路基本结构**: "···· - 状态元件 - 组合逻辑元件 - 状态元件 - ·····"  
**数据通路要求**:  
   - 只有状态元件能够存储信息  
   - `所有组合逻辑元件`都须`从状态元件接受输入`，并`将输出写入状态元件中`  
   - `所有状态元件`在`同一时钟`控制下写入信息  

**数据通路的时间周期**: $cycle\ time = Clk-to-Q + longest\ delay + setup\ time + clock\ skew$
   - `longest delay`: 各级组合逻辑电路的传输延迟(最长延迟)  
   - `clock skew`: 时钟偏移[^1]  
   - `Clk-to-Q`: 锁存延迟,时钟触发边沿到来到状态元件输出端改变的时间  
   - `setup time`: 建立时间，时钟触发边沿来之前输入端必须稳定的最短时间  

**数据通路应满足的时间约束**: $Clk-to-Q + shortest\ delay > hold\ time$
   - `shortest delay`: 各级组合逻辑电路的最短延迟  
   - `hold time`: 保持时间,时钟触发边沿来之后输入端D必须稳定的最短时间   
   - **原因**: 若不满足，则可能`存在一个路径`使得输入值更新，导致输入没有满足`保持时间`或出现`冒险现象`.

##  计算机性能与CPU时间
`吞吐率`和`响应时间`是考量<font color=purple>计算机系统性能的两个基本指标</font>  
- `吞吐率`: 表示单位时间内所完成的工作量  
- `响应时间`: 指从作业提交开始到作业完成所用的时间  

> 通常情况下，一个程序的执行时间除了程序包含的指令在CPU上执行所用的时间外，还包括磁盘访问时间、输入/输出操作所需时间以及操作系统运行这个程序所用的额外开销等.<font color=blue>因此用户感觉到执行时间分成以下两部分:<u>用户CPU时间</u>和<u>其他时间</u></font>  

**用户CPU时间**: 指CPU用于执行本程序包含所有指令的时间  
**其他时间**: 指操作系统程序执行时间以及等待I/O操作完成的时间或CPU用于执行其他用户程序的时间。

**系统性能**: 指系统的响应时间,与CPU性能相关，但也与CPU外的其他部分有关  
**CPU性能**: 指`用户CPU时间`  

评判计算机性能的好坏: 比较`用户CPU时间`的倒数  

### 计算用户CPU时间
<font color=purple>要用到的相关概念</font>:  
   - **时间周期**: 用于CPU操作定时的时钟信号的宽度.控制信号何时发出、作用时间有多长  
   - **时间频率**: CPU时间周期的倒数，通常称为`主频`  
   - **CPI(Cycles Per Instruction)**: `执行一条指令所需的时钟周期数`。对一条指令来说，CPI是一个确定的值。对一个程序或一台机器来说，CPI是一个平均值  

<font color=teal>$\text{用户CPU时间} = \text{程序总时钟周期数} \times \text{时间周期}$</font>  
$\text{程序总时间周期数} = \text{程序总指令条数} \times CPI$  

# 单周期CPU设计
**功能**: 每个周期执行一条指令  
**CPU设计过程**:通常涉及`数据通路`和`控制部件`的设计  
1. <font color=green>分析每条指令的功能</font>: 查看RSIC-V手册即可知  
2. <font color=green>实现每条指令的数据通路</font>: 根据指令的功能给出<font color=purple>所需的基本功能部件</font>，单独实现他们并将他们互连  
3. <font color=green>确定每个基本功能部件<u>所需控制信号的取值</u></font>  
4. 汇总所有指令设计的控制信号，生成反映<font color=green>指令操作码与控制信号之间关系的<u>真值表</u></font>  
5. 根据真值表，<font color=skyblue>得到每个控制信号的逻辑表达式</font>，据此设计控制器  

---


**选择<font color=purple>具有代表性</font>的以下9条RV32I指令作为实现目标**:  
- R-型指令:  
```
add     rd, rs1, rs2
slt     rd, rs1, rs2
sltu    rd, rs1, rs2
```
- I-型指令:  
```
ori     rd, rs1, imm12
lw      rd, rs1, imm12
```
- U-型指令:  
```
lui     rd, imm20
```
- S-型指令:  
```
sw      rs1, rs2, imm12
```
- B-型指令:  
```
beq     rs1, rs2, imm12
```
- J-型指令:  
```
jal     rd, imm20
```

## 指令功能的描述
RISC-V手册对指令功能有了详细的描述  

## 单周期数据通路的设计
### 扩展器部件的设计
![img](img/9条目标指令的扩展器功能实现.png '图4 9条目标指令的扩展器功能实现. :size=100%')  
**功能**: 根据`不同的指令格式`生成正确的立即数  
**控制信号**: `ExpOp`扩展操作码,选择与输入指令对应的立即操作数输出  
**得到各个指令与控制信号的真值表**: 可以自己定义  
![img](img/控制信号ExtOp与对应指令的真值表.png '图5 控制信号ExtOp与对应指令的真值表示例 :size=100%')  

### 算术逻辑部件的设计
> 为了支持这9条指令包含的运算，ALU必须具有相应的功能:<font color=green>加法、带符号整数的大小判断、无符号数的大小判断、相等判断以及各种逻辑运算等</font>  

![img](img/9条目标指令的ALU实现.png '图6 9条目标指令的ALU实现 :size=70%')  
**控制信号生成部件**: 由信号`ALUctl`来控制部件生成的控制信号(`SUBctl`,`OPctl`,`SIGctl`...<font color=purple>还可根据未来的要实现的功能补充</font>)  
   - `SUBctl`: 控制ALU执行加法还是减法运算,$SUBctl = 1$时，做减法  
   - `OPctl`: 控制选择那种运算的结果作为Result输出,如这9个指令中有`加`、`按位或`、`操作数B选择`、`小于置1`这四种运算，所以`OPctl`只需要两位  
   - `SIGctl`: 控制ALU是执行`带符号整数比较小于置1`($SIGctl=1$)还是`无符号数比较小于置1`  

![img](img/9条目标指令对应的3种ALU操作控制信号真值表.png '图7 9条目标指令对应的3种ALU操作控制信号真值表. :size=70%')  

> 当前时间周期内执行的运算结果总是在下一个时间周期到来时，开始写到寄存器zuza中，为了鞥你写入正确的稳定结果，`ALUctr`必须稳定一段时间保持不变  

### 取指令部件的设计
![img](img/取指令部件示意图.png '图8 取指令部件示意图 :size=100%')  
**功能**: 每来一个时钟信号，从PC指向的地址从`指令存储器`中取指，更新一次PC  
**下地址逻辑**: 区分是`顺序执行`还是`转移执行`来以不同的方式更新PC.具体实现见后  


### R-型指令的数据通路
![img](img/支持R-型指令功能的数据通路.png '图9 支持R-型指令功能的数据通路 :size=100%')
![img](img/通用寄存器.png '图10 通用寄存器 :size=60%')  

**控制信号**: `RegWr`写使能信号。  

### I-型运算指令的数据通路
![img](img/支持I-型带立即数运算指令功能的数据通路.png '图11 支持I-型带立即数运算指令功能的数据通路. :size=100%')  

**控制信号**: `ALUBSrc`，控制选择`busB`还是`扩展器输出imm`作为ALU的B口操作数  

### U-型指令的数据通路
![img](img/支持lui指令功能的数据通路.png '图12 支持lui指令功能的数据通路. :size=100%')  

### Load/Store指令的数据通路
![img](img/支持Load-Store指令功能的数据通路.png '图13 支持Load,Store指令功能的数据通路 :size=100%')  
**控制信号**`MemWr`:,存储器写使能信号  
**控制信号**`MemtoReg`:控制将`ALU结果`还是`存储器读出的数据`写入目的寄存器  


### B型指令的数据通路
![img](img/支持B-型指令功能的数据通路.png '图14 支持B-型指令功能的数据通路. :size=100%')  

**部分功能**: 在`下地址逻辑`中实现转移目标地址计算  
**控制信号**`Branch`: 表示当前指令是否是分支指令，送到`下地址逻辑`中，决定是否按分支指令方式计算下条指令地址(通常还需要其他条件，如零标志)  

![img](img/B型分支指令的下地址逻辑设计.png '图15 分支指令的下地址逻辑设计 :size=60%')  

### J型指令的数据通路
![img](img/支持J-型指令功能的数据通路.png '图16 支持J-型指令功能的数据通路. :size=80%')  

**控制信号**`ALUASrc`: 选择是`busA`还是`当前PC`作为ALU的A口操作数  
**控制信号**`ALUBSrc`: 选择是`busB`,`4`还是`扩展器输出imm`作为ALU的B口操作数  
**控制信号**`Jump`: 表示当前指令是否是J-型指令  
![img](img/完整的取指令部件实现.png '图17 完整的取指令部件实现 :size=50%')  

### 综合9条指令的完整数据通路
![img](img/支持9条目标指令的完整单周期数据通路.png '图18 支持9条目标指令的完整单周期数据通路 :size=100%')  

## 控制器的设计
![img](img/支持9条目标指令的单周期CPU.png '图19 支持9条目标指令的单周期CPU :size=100%')  
> **虚线**: 为各种控制信号  


**<font color=blue>表1: 单周期CPU中包含的控制信号</font>**
|    **控制信号**    |     **用途**      |
| ------------- |-------------  |
|    `ExtOp`    |    扩展器部件控制信号，根据不同指令格式，选择不同的立即数输出          |  
|    `ALUctr`    |  控制ALU操作控制信号生成部件生成控制信号`SUBctl`,`OPctl`,`SIGctl`,...     |
|    `SUBctl`    |     控制ALU执行减法还是加法         |
|    `OPctl`    |     控制选择哪种运算的结果作为ALU输出         |
|    `SIGctl`    |     控制ALU执行`带符号整数比较小于则置1`还是`无符号数比较小于则置1`         |
|    `RegWr`    |     通用寄存器写使能         |
|    `ALUASrc`    |     控制选择`busA`还是`当前pc`作为ALU B口操作数          |
|    `ALUBSrc`    |    控制选择`busB`还是`扩展器输出imm`作为ALU B口操作数          |
|    `MemWr`    |     存储器写使能信号         |
|    `MemtoReg`    |     控制将`数据存储器读出的值`还是`ALU结果`写入目标寄存器        |
|    `Branch`    |     表示当前指令是否是分支指令(即是否是B-型指令)         |
|    `Jump`    |     表示当前指令是否是J-型指令         |



1. 根据控制信号真值表得到`各个控制信号逻辑表达式`  
2. 即可画出控制器的逻辑电路  

## 时间周期的确定
通常选择**最复杂指令**所用的指令周期  
![img](img/load指令执行过程的定时.png '图20 load指令执行过程的定时. :size=100%')  



[^1]: 时钟偏移: 由于器件工艺和走线延迟等原因造成的同步系统中时钟信号的偏差，这种时间偏差是的时钟信号不能同时到达不同的状态元件而导致同步定时错误。

