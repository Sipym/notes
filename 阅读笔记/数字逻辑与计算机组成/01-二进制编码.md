# 计算机系统概述
## 冯·诺伊曼结构计算机
:star:<font color=purple>冯·诺伊曼结构思想</font>:绝大部分通用计算机仍然具有冯·诺伊曼结构特征  
   - 采用"存储程序[^1]"工作方式  
   - 计算机由运算器、控制器、存储器、输入设备和输出设备5个基本部件组成  
   - 存储器不仅能够存放数据，也能存放指令,<font color=blue>形式上数据和指令没有区别</font>,计算机能够区分他们  
   - 控制器能自动控制指令的执行;  
   - 运算器能够进行算术，逻辑运算;  
   - 操作人员能够通过输入/输出设备使用计算机  
   - 计算机内部以二进制形式表示指令和数据;<font color=red>每条指令由操作码和地址码两部分组成</font>  

<font color=purple>依上可给出一个模型机的硬件基本结构</font>:  

![img](img/模型机的硬件基本结构.png  '图1-模型机的硬件基本结构 :size=80%')

- `中央处理器`(<font color=red>CPU</font>, Central Processing Unit): 把控制部件、运算部件和各类寄存器互连组成的电路称为中央处理器  
- `主存储器`(<font color=red>MM</font>, Main Memory): 存放那个指令和数据的存储部件，简称主存或内存  

###  存储器
`主存地址`:主存中的每个单元需要编号,称为主存地址  
`总线`: 连接不同部件(如MM和CPU)进行<font color=blue>信息传输的介质</font>  
   - > 包含分别用于<u>传输地址信息</u>、<u>数据信息</u>和<u>控制信息</u>的<font color=blue>地址线</font>、<font color=blue>数据线</font>和<font color=blue>控制线</font>  

`主存地址寄存器`(<font color=red>MAR</font>, Memory Address Register): 用于存放CPU送到地址线的主存地址,MAR位数与地址线位数相同  
`主存数据寄存器`(<font color=red>MDR</font>,Memory Data Register): 存放发送到数据线或从数据线去来的信息,MDR位数与数据线位数相同  
###  运算器
`算术逻辑部件`(<font color=red>ALU</font>): 计算机最基本的运算器,用于算术运算和逻辑运算的部件  

:star:`通用寄存器组`(<font color=red>GPRs</font>,General Purpose Register set): 可以为ALU提供操作数，临时存放从主存取来的数据或运算的结果  
   - > 需要给每个通用寄存器编号  

###  控制器
`控制部件`(<font color=red>CU</font>,Control Unit): 能够自动读取指令并对指令进行译码的部件  
`指令寄存器`(<font color=red>IR</font>,Instruction Register):存放从主存取来的指令  
`程序计数器`(<font color=red>PC</font>,Program Counter): 存放将要执行的下一条指令所在的主存地址  
   - > 为了自动按序读取主存中的指令，在执行当前指令的过程中，将自动计算出下一条指令的主存地址  

###  输入/输出设备: 又称I/O设备
用于和用户进行交互

##  程序的表示与执行
`程序的执行过程`: 从主存取指令、对指令进行译码、PC增量、取操作数并执行、将结果送到主存或寄存器保存  
###  程序的表示
`程序的表示`:分为机器级语言和高级编程语言   
####  机器级语言: 与特点机器结构相关
> 汇编语言和机器语言都属于<font color=purple>低级编程语言</font>，统称为<font color=purple>机器级语言</font>,所编写的程序成为<font color=purple>机器级代码程序</font>  

`机器代码(机器语言程序)`: 计算机能直接理解和执行用机器语言编写的程序  
`汇编语言`: 用<font color=red>简短的英文符号</font>和<font color=red>机器指令建立对应关系</font>的语言。
   - `汇编指令`: 机器指令对应的符号  

####  高级编程语言
`高级编程语言`: 与具体机器结构无关，比机器级语言可读性更好，描述能力更强  

####  翻译程序
**功能**:把一种编程语言表示的程序转换为等价的另一种编程语言  
**类别**: 汇编程序，解释程序，编译程序  
   - **汇编程序(assembler)**: 也称汇编器，用来将<font color=purple>汇编语言</font>源程序翻译成<font color=purple>机器语言</font>目标程序  
   - **解释程序(interpreter)**: 也称解释器,用来将源程序中的语句<font color=purple>按其执行顺序逐条翻译成机器指令</font>并<font color=purple>立即执行</font>  
   - **编译程序(compiler)**: 也称编译器，用来将<font color=red>高级语言源程序翻译成</font><font color=purple>汇编语言</font>或<font color=purple>机器语言</font>目标程序  

## :star: 计算机系统抽象层(在这张解析了软件到硬件的详细过程)
![img](./img/计算机系统抽象层机极其转换.png '图2-计算机系统抽象层机极其转换 :size=50%')  
> 描述了用户<font color=purple>希望计算机完成的应用(问题)</font> `->` 电子工程师使用器件完成<font color=purple>基本电路设计</font>的整个过程  

- > **软件层面**:  `应用(问题)`描述 **->** `算法`分析(使用何种) **->** `高级编程语言`设计 **->** 根据不同`操作系统`转换为特定的<font color=brown>机器语言</font>  
- > **桥梁**: <font color=red>ISA(指令集架构)</font>, 定义了一台计算机可以执行的所有指令的集合,<font color=brown>机器语言程序就是一个ISA规定的指令的序列</font>  
- > **硬件层面**:  实现ISA的具体逻辑结构`计算机组成(或微体系结构)` **->** 微架构的`功能部件组成` **->** 各个功能部件的`数字逻辑电路`设计 **->** 基本逻辑门电路的`器件技术`实现  

# 二进制数的表示
##  进位计数制
**R进制**:  
   - > 基本符号: 0, 1, 2, ... , R-1  
   - > 计数规则: 逢R进一  
   - > 对于每一个数位i,该位权为$R^i$  

`常用进制的字母表示`: 二进制(B), 八进制(O), 十进制(D), 十六进制(H)  

##  进制间的转换
###  十进制准转换为R进制数  
(1)**整数部分的转换**:  
   - `转换方法`: 除基(R)取余,上低下高  

(2) **小数部分的转换**:  
   - `转换方法`: 乘基取余, 上高下低  
![img](img/十进制数小数部分转换为八进制数实例.png '图 十进制数小数部分转换为八进制数实例 :size=50%')

(3) <font color=purple>简便的十进制转换为二进制的方法</font>:  

![img](img/十进制转换为二进制简便方法.png '十进制转换为二进制简便方法 :size=50%')

##   数值型数据的编码表示
> :bulb: 任何一个二进制0/1序列，在<font color=purple>未确定</font>采用的`进位计数制`、`定点还是浮点`以及`编码方法`前，<font color=blue>值是不确定的</font>  

浮点数 = 定点整数 + 定点小数,所以<font color=red>只需考虑定点数的编码表示</font>  
<font color=purple>定点数编码表示方法</font>: `原码`，`补码`，`反码`和`移码`  

###  定点数的编码方式
> 符号说明: 机器数`X`, 机器数的真值`X_T`    

**真值$X_T$的表示**:  
   - X为定点整数: <font color=red>$X_T = \pm X_{n-2}' ... X_1' X_0'$</font>  
   - X为定点小数: <font color=red>$X_T = \pm 0.X_{n-2}' ... X_1' X_0'$</font>  

**机器数X的表示**:<font color=red>$X = X_{n-1}X{n-2}···X_{1}X_{0}$</font>  
   - $X_{n-1}$: 为符号位  

#### (1)原码表示法
**原码编码规则如下**:  
   1. 当$X_T$为正数时，$X_{n-1}=0, X_i = X_i'$  
   2. 当$X_T$为负数时，$X_{n-1}=1, X_i = X_i'$  
   3. `0的表示形式`:  
      - $[+0] = 000···0$  
      - $[-0] = 100···0$  

**优点**: 编码值与真值对应关系直观方便  
**缺点**: <font color=purple>0的表示不唯一</font>,原码运算中符号和数值部分必须分开处理  

#### (2)补码表示法(常用)

##### 模运算(补码的原理)
$A \equiv B \pmod{m}$: A,B除与M后的余数相同,**称为A与B共模M**  

$$\begin{align}
\text{由}: A \equiv  B (\mod B) \\
\text{有}: A - B \equiv A + (M -B) \\
\end{align}$$
> **<font color=blue>解释</font>**: 在取余M后，上面两个等式很容易得出是等价的，而在计算机系统中,数值的位数是一定的，所以也可以用这种方式来定义补码，而不会改变值的意义  

---
##### 补码编码规则
   1. 当$X_T$为正数时，$[X_T]_\text{补} = M + X_T (\mod{M})$   
   2. 当$X_T$为负数时，$[X_T]_\text{补} = M - |X_T| = M + X_T (\mod{M}) = M + X_T (\mod{M})$  
   3. `总结`:对于任意数有<font color=red>$[X_T]_\text{补} = M + X_T (\mod{M})$</font>   
      - 对于n位二进制制补码来说,有$[X_T]_\text{补} = 2^n + X_T$  

n位补码能表示数值范围: $-2^{n-1} \leq X_T < 2^{n-1}$

---

`优点`: 可以<font color=purple>实现加减运算的同一</font>，即用加法实现减法运算  
`注意1`: 不能表示$2^{n-1}$  
`注意2`: 补码$2^{n-1}$对应的是最小负数$-2^{n-1}$  
`用处`: 用来表示带符号整数  


##### 补码与真值之间的转换
正数的补码: 符号转换为0,其他不变  
<font color=red>负数的补码</font>: 符号转换位1,数值部分"<font color=purple>各位取反，末位加1</font>"  
    - > `以8位补码为例`:$[X_T]_\text{补} = 2^8 + X_T = 2^7 + 2^7 + X_T = 2^7 + 1111111 + 1 + X_T = 2^7 + (1111111+ X^T) + 1$  

<font color=red>负数补码的真值</font>:符号为负,<font color=purple>各位取反，末位加1</font>  


##### 变形补码
`概念`: 双符号位的补码表示方式
`特点`: 左符是真正的符号位,右符判断结果是否溢出  

#### (3)反码表示法
`负数的反码`: 符号位为1,各位取反  

#### (4)移码表示法
> `用途`: 用来表示浮点数的阶(定点整数)  

`移码概念`: 对每个阶(定点整数)都加上一个正的常数，成为偏置常数(bias),使所有阶转换为正整数  
`优点`: 简化了浮点数之间的比较操作，将阶转换为正整数，可以直观的将两个数按位从左到右进行比对,简化了对阶操作  

`移码的编码表示`: $[E]_\text{移} = \text{偏置常数}+E$,<font color=purple>偏执常数取$2^{n-1}$或$2^{n-1} -1$</font>  

### 整数的表示






































[^1]:<font color=brown>"存储程序"方式基本思想</font>:必须事先编好程序，并将程序和原始数据送入存储器后才能执行程序;一旦程序被启动执行，计算机能在不需操作人员干预的情况下自动从存储器中逐条取出指令并执行指令  


