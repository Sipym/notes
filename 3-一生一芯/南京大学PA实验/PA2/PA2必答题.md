# PA2
## RTFM
**题目**:  整理一条指令在NEMU中的执行过程  

**解答**: auipc指令的执行过程  
> 1. 进入sdb_mainloop()函数后，等待用户的指令 
> 2. 输入si 1,将执行客户用户程序的第一条指令`auipc to,0`  
> 3. 一系列步骤后，将执行`isa_exec_once()`函数，用于取指，译码并执行   
> 4. 取指: 使用`inst_fetch()`函数获取指令  
> 5. 进入译码函数`decode_exec()`  
> 6. 模式匹配，根据指令特定的opcode找到该指令的模式匹配规则  
> 7. 执行函数`decode_operand()`,获取rd的值  
> 8. 因为类型为`TYPE_U`,执行`immU()`获取立即数  
> 9. 执行命令:`R(dest) = s->pc + imm;`  

---


## 基础设施
![img](img/游戏是如何运行的.png '图1 游戏是如何运行的 :size=60%')  
1. 调用`init_vedio`,将界面初始化为紫色背景,...  
2. 进入死循环  
   - 读取设备`AM_TIMER_UPTIME`,用来得到`当前已经运行的帧数`  
   - 更新字符char[N_CHAR]的状态(新增字符，字符下落...)
   - 读取设备`AM_INPUT_KEYBRD`,得到按下的键码  
   - 进行判断，如果屏幕里存在正常下落的字符，则hit++,字符消失  
   - 写设备`AM_GPU_FBDRAW`:更新vga  
   - 重复上述步骤

---
![img](img/static与inline的作用.png 'static与inline的作用. :size=70%')  
**发生错误的情况**: 去掉static和inline  
   - `为什么发生`: 当头文件中包含了`函数的本体`时，则每次包含该头文件，都会将该函数的副本写入源文件  
      - 从而导致，多处定义，导致链接错误  
**只去掉static为什么不发生**:   
   - `inline`使得函数本体会加载到函数的调用点中。从而使得加载进源文件的程序副本被限制到了调用处的作用域中  
**只去掉inline为什么不发生**:  
   - `static`将加载进源文件的副本函数的作用域限制在了源文件，从而避免了冲突  

![img](img/编译与链接1.png '编译与链接1 :size=70%')   
解答: 通过`grep 'common.h` -r .得到所有引用该头文件的文件，再经过`grep` 正则表达式筛选出所有.c,.cc文件，即可得到  




